# Mariodux
Demonstration on how [Redux](https://github.com/reactjs/redux) and [morphdom](https://github.com/patrick-steele-idem/morphdom) can be added to a  [Marionette](https://github.com/marionettejs/backbone.marionette) project in order to provide the benefit of popular [React](https://github.com/facebook/react) and [Flux](https://facebook.github.io/flux/) features; specifically, DOM diffing and unidirectional data flow.

## Motivation
I currently work on a 3-year-old Marionette project where migrating to React or any other framework would be a massive effort. I began this repo to determine if it would possible to replicate the Flux pattern within a Marionette application.

The results were interesting …

## The Approach
We start by creating [two versions of the application's root layout](https://github.com/AndrewHenderson/mariodux/blob/master/examples/todos/index.js#L13-L14).
```js
var root = new Root();
var virtualRoot = new Root();
```
The [true root is then attached to the document](https://github.com/AndrewHenderson/mariodux/blob/master/examples/todos/index.js#L44) and acts as the representation of application state.
```js
app.rootRegion.show(root);
```
The virtual root will essentially act as the worker. It will be used to re-render given the new global state object. An HTML representation of this latest rendering will then be diffed against the true root currently in the DOM. Morphdom will then handle efficiently updating that DOM.

## Pricipals
Following the [Redux pricincples](http://redux.js.org/docs/introduction/ThreePrinciples.html), childViews will leverage pure functions to update their models by [dispatching events](https://github.com/AndrewHenderson/mariodux/blob/master/examples/todos/components/TodoList.js#L53-L55) rather than setting properties on the model directly.
```js
onClick: function() {
  dispatch(toggleTodo(this.$el.attr('modelId')));
}
```
In doing so, a new global state object will be generated by  [combineReducers](https://github.com/AndrewHenderson/mariodux/blob/master/examples/todos/reducers/index.js#L9-L12), the `updateDOM` function will execute, rendering the virutalRoot using latest global state. Morphdom will then diff the newly rendererd virtualDOM with the realDOM and efficiently update the realDOM.
```js
store.subscribe(function updateDOM() {
  var realDOM = root.$el[0];
  var virtualDOM = virtualRoot.render().$el[0];
  morphdom(realDOM, virtualDOM);
});
```
The true root will not be re-rendered. It is only rendered once at the start. From then on, morphdom will do the DOM updating.

Using this approach, each childView will only have to be concerned with rendering once and dispatching events in order to re-render the virtualRoot.

## Shift In Mindset
Backbone and Marionette were both designed to work with an event listener pattern leveraging functions like `modelEvents`, `collectionEvents`, `listenTo`, etc. This approach ignores those functions in favor of the more predictable immutable global state object — the app's single source of truth.

## Things To Note
As an alternative to the complexities of something like [React's synthetic event system](https://facebook.github.io/react/docs/working-with-the-browser.html), we will continue to listen for DOM events in the view on the [events object](https://github.com/AndrewHenderson/mariodux/blob/master/examples/todos/components/TodoList.js#L30-L32).
```js
events: {
  click: 'onClick'
}
```
One issue that arises from this however, is the DOM node may have been efficiently updated by morphdom and thus represent data which is not in the view object's model — the one that was originally used to render the node.

Since we only need the model for the purposes of rendering, a workaround for this is to put the `model.id` on the node in a custom attribute. This way, [the proper id can be used when notifying the dispatcher](https://github.com/AndrewHenderson/mariodux/blob/master/examples/todos/components/TodoList.js#L54).
